bond.ladder
seq((nrow(liab.partb)-1),1)
for (i in seq((nrow(liab.partb)-1),1)){
bond.ladder$F[i] = (liab.partb$amount[i] - bond.ladder$cum.coupon[i+1])/(1+bond.ladder$coupon[i])
cum.coupon[i] = cum.coupon[i+1] + F[i] * bond.ladder$coupon[i]
}
bond.ladder$cum.coupon[12] <- bond.ladder$coupon[12]*bond.ladder$F[12]
# end   question 10
#----------------------------------------------------
# start question 11
bond.ladder <- Treasury_bond[maturity %in% liab.partb$date,]
bond.ladder$F[12] <- liab.partb$amount[12]/(1+bond.ladder$coupon[12])
bond.ladder$cum.coupon[12] <- bond.ladder$coupon[12]*bond.ladder$F[12]
for (i in seq((nrow(liab.partb)-1),1)){
bond.ladder$F[i] = (liab.partb$amount[i] - bond.ladder$cum.coupon[i+1])/(1+bond.ladder$coupon[i])
bond.ladder$cum.coupon[i] = bond.ladder$cum.coupon[i+1] + bond.ladder$F[i] * bond.ladder$coupon[i]
}
bond.ladder
sum(bond.ladder$F)
tot.cost <- sum(bond.ladder$F)
answer11 = tot.cost              ### replace NA with R code generating the answer
cat("Answer Q11:", answer11,'\n')
sum(liab.partb$amount)
sum(liab.partb$amount) - tot.cost
# Student name:  Julia Tsai
################################################################################
# Follow the "R Submission File Instructions" page on Canvas to receive 5 points:
# -use setwd() to set the working directory
# -do not include the working directory as part of the name of a file
# -do not use file.choose()
# -use load() to load RData files
# -place R code for each question in the space provided below
# -replace NA for each answer with the R code generating the answer
# -type the numerical answer on Canvas
################################################################################
# Full credit on numerical questions is given if:
# - the R code in the appropriate place for that question run
# - the R code generates the answer matching the numerical answer typed into Canvas
# - the numerical answer is correct
####################################################################################
###### REMEMBER TO UPLOAD YOUR R SUBMISSION FILE
###### On time submission via Canvas will receive a five (5) point submission credit.
###### Submission via email will not receive the five (5) point submission credit.
###### Submission via email after five minutes of the due time will not be accepted.
####################################################################################
# Useful R functions
library(jrvFinance)
library(data.table)
# useful functions in jrvFinance
# bond.price(settle,mature,coupon,freq,yield,convention,comp.freq)
# bond.yield(settle,mature,coupon,freq,price,convention,comp.freq)
# bond.TCF(settle,mature,coupon,freq,convention)
# coupons.dates(settle,mature,freq)
# bond.duration(settle,mature,coupon,freq,yield,convention,modified=FALSE,comp.freq)
# irr(cf,interval=NULL,cf.freq=1,comp.freq=1,method="default")
#
setwd("E:/MQM_Courses/Term4/FixedIncomeSecurities/FixedIncome_codes/datas")
# define DATE() function
DATE <- function(yyyy,mm,dd) {
dte  <- as.Date(sprintf("%i-%i-%i",yyyy,mm,dd),format="%Y-%m-%d")
return(dte)
}
as.Date2 <- function(x) {
tryfmt <- c("%Y-%m-%d","%m/%d/%Y","%Y/%m/%d","%b %d,%Y")
return(as.Date(x,tryFormats=tryfmt))
}
# zero coupon price function
zcb.price <- function(zcb.yield,ttm,comp.freq=2) {
return( 100/(1+zcb.yield/comp.freq)^(comp.freq*ttm) )
}
# zero coupon yield function
zcb.yield <- function(zcb.price,ttm,comp.freq=2) {
return( comp.freq * ( (100/zcb.price)^(1/(comp.freq*ttm)) - 1 ) )
}
# function to calculate convexity of a coupon bond
bond.convexity <- function(settle,mature,coupon,freq=2,yield,convention,comp.freq=freq) {
z  <- as.data.frame(bond.TCF(settle,mature,coupon,freq,convention))
cf <- z$cf
t  <- z$t
r  <- yield
m  <- comp.freq
return ( 1/sum( cf / (1+r/m)^(t*m) ) * sum( t * (t+1/m) * cf / (1 + r/m)^(t*m+2) ) )
}
##########################
##### File Download  #####
##########################
load('final.RData',verbose=TRUE)   # do not use file.choose()
# this is the output
# Loading objects:
#   Treasury_ci
#   Treasury_bond
#   sofr.frbny
#   sr3.fut
#   liab.partb
#   qtree
#   ztree
#
# Treasury_ci has two columns:
#  maturity   is the maturity date of the coupon STRIPS, in 'Date' format
#  price      is the price of the coupon STRIPS per $100 of face value
# Treasury_bond has four columns:
#   maturity   is the maturity date of the treasury bond, in 'Date' format
#   coupon     is the annual coupon rate of the treasury bond, in decimal form
#   pclean     is the clean price of the treasury bond, per $100 of face value
#   yield      is the yield-to-maturity of the treasury bond, in decimal form, semi-annual compounded
# sr3.fut has four columns:
#   MMY           is the year and month of the futures (format as YYYYMM).
#   StartDt       is the start date of the reference quarter of the SOFR 3-month futures contract
#   MatDt         is the end date of the reference quarter of the SOFR 3-month futures contract
#   SettlePrice   is the settlement price of these futures contract, on 2024-02-12.
# sofr.nyfrb has two columns:
#   Date          is the date of the SOFR, as computed by the Federal Reserve Bank of New York
#   SOFR          is the SOFR for the given date
# qtree is a 10 x 10 matrix of up probabilities
# ztree is a 10 x 10 matrix of 1-period spot rates
##################
##### Part B #####
##################
# start question 10
settle <- DATE(2024,02,12)
Treasury_ci[, ttm := as.numeric(maturity - settle)/365]
liab.partb[, ttm := as.numeric(date - settle)/365]
Treasury_ci[, spot := zcb.yield(price, ttm)]
liab.partb$spot <- spline(x=Treasury_ci$ttm, y=Treasury_ci$spot, xout=liab.partb$ttm,method="natural")$y
liab.partb[, disfac := 1/(1+spot/2) ^ (2*ttm)]
liab.partb[, pv := amount*disfac]
PV <- sum(liab.partb$pv)
liab.partb[, wi := pv/PV]
liab.partb[, wtcon := wi * ttm * (ttm + 0.5)/ (1 + spot/2)^2]
convexity <- sum(liab.partb$wtcon)
answer10 = round(convexity,3)         ### replace NA with R code generating the answer
cat("Answer Q10:", answer10,'\n')
# end   question 10
#----------------------------------------------------
# start question 11
bond.ladder <- Treasury_bond[maturity %in% liab.partb$date,]
bond.ladder$F[12] <- liab.partb$amount[12]/(1+bond.ladder$coupon[12])
bond.ladder$cum.coupon[12] <- bond.ladder$coupon[12]*bond.ladder$F[12]
for (i in seq((nrow(liab.partb)-1),1)){
bond.ladder$F[i] = (liab.partb$amount[i] - bond.ladder$cum.coupon[i+1])/(1+bond.ladder$coupon[i])
bond.ladder$cum.coupon[i] = bond.ladder$cum.coupon[i+1] + bond.ladder$F[i] * bond.ladder$coupon[i]
}
tot.cost <- sum(bond.ladder$F)
answer11 = tot.cost              ### replace NA with R code generating the answer
cat("Answer Q11:", answer11,'\n')
# start question 12
settle <- DATE(2024,02,12)
settle
View(sr3.fut)
View(sofr.frbny)
fixed.rate <- 0.045
notional <- 100000000
start.date <- DATE(2023,12,20)
end.date <- DATE(2027,12,20)
data.table(year = seq(0,4))
data.table(year = seq(0,4),
paydate = seq(start.date, end.date, by = "year"))
data.table(year = seq(0,4),
paydate = seq(start.date, end.date, by = "year"))
payments <- data.table(year = seq(0,4),
paydate = seq(start.date, end.date, by = "year"))
payments[, D = day(year(paydate))]
payments$D[i] <- as.numeric(payments$paydate[i] - payments$paydate[i-1])
for (i in 1:nrow(payments)){
payments$D[i] <- as.numeric(payments$paydate[i] - payments$paydate[i-1])
}
payments$D <- NA
for (i in 1:nrow(payments)){
payments$D[i] <- as.numeric(payments$paydate[i] - payments$paydate[i-1])
}
payments$D <- 0
for (i in 1:nrow(payments)){
payments$D[i] <- as.numeric(payments$paydate[i] - payments$paydate[i-1])
}
payments$D <- NA
for (i in 2:nrow(payments)){
payments$D[i] <- as.numeric(payments$paydate[i] - payments$paydate[i-1])
}
payments
payments[,fixed.cf := fixed.rate * D/360 * notional]
payments
float <- sofr.frbny[date >= start.date & date <= end.date]
float
float[,di := c(as.numeric(diff(date)),0)]
float[, gross_daily_rate := 1 + SOFR/100*di/360 ]
float[, cum_rate := cumprod(gross_daily_rate)]
float
float$cum_rate[.N]
float[.N]$cum_rate
payments
(float[.N]$cum_rate-1)*sum(D)/360*notional
payments$float.rate <- NA
for (i in 2:nrow(payments)){
float <- sofr.frbny[date >= payments$paydate[i-1] & date <= payments$paydate[i]]
float[,di := c(as.numeric(diff(date)),0)]
float[, gross_daily_rate := 1 + SOFR/100*di/360 ]
float[, cum_rate := cumprod(gross_daily_rate)]
payments$float.rate[i] <- float[.N]$cum_rate-1
}
payments
float
for (i in 2:nrow(payments)){
float <- sofr.frbny[date >= payments$paydate[i-1] & date <= payments$paydate[i]]
float[,di := c(as.numeric(diff(date)),0)]
float[, gross_daily_rate := 1 + SOFR/100*di/360 ]
float[, cum_rate := cumprod(gross_daily_rate)]
print(float)
payments$float.rate[i] <- float[.N]$cum_rate-1
}
float <- sofr.frbny[date >= payments$paydate[i-1] & date <= payments$paydate[i]]
float[,di := c(as.numeric(diff(date)),0)]
float[, gross_daily_rate := 1 + SOFR/100*di/360 ]
float[, cum_rate := cumprod(gross_daily_rate)]
print(float)
payments$float.rate[i] <- float[.N]$cum_rate-1
float <- sofr.frbny[date >= start.date & date <= end.date]
float[,di := c(as.numeric(diff(date)),0)]
float[, gross_daily_rate := 1 + SOFR/100*di/360 ]
float[, cum_rate := cumprod(gross_daily_rate)]
print(float)
payments$float.rate[i] <- float[.N]$cum_rate-1
float[.N]$cum_rate-1
float <- sofr.frbny[date >= start.date & date <= end.date]
float[,di := c(as.numeric(diff(date)),0)]
float[, gross_daily_rate := 1 + SOFR/100*di/360 ]
float[, cum_rate := cumprod(gross_daily_rate)]
float[.N]$cum_rate-1
print(float)
float <- sofr.frbny[date >= start.date & date <= end.date]
float[, di := c(as.numeric(diff(date)),0)]
float[, gross_daily_rate := 1 + SOFR/100*di/360 ]
float
payments
for (i in 2:nrow(payments)){
t0 = payments$paydate[i-1]
t1 = payments$paydate[i]
rate = float[date >= t0 & date <= t1]
rate[, cum_rate := cumprod(gross_daily_rate)]
payments$float.rate[i] <- rate[.N]$cum_rate-1
}
float <- sofr.frbny[date >= start.date & date <= end.date]
float[, di := c(as.numeric(diff(date)),0)]
float[, gross_daily_rate := 1 + SOFR/100*di/360 ]
for (i in 2:nrow(payments)){
t0 = payments$paydate[i-1]
t1 = payments$paydate[i]
rate = float[date >= t0 & date <= t1]
rate[, cum_rate := cumprod(gross_daily_rate)]
payments$float.rate[i] <- rate[.N]$cum_rate-1
}
payments
?last
cum_rate = cumprod(float$gross_daily_rate)
cum_rate
last(cum_rate)
for (i in 2:nrow(payments)){
t0 = payments$paydate[i-1]
t1 = payments$paydate[i]
rate = float[date >= t0 & date <= t1]
cum_rate = cumprod(rate$gross_daily_rate)
payments$float.rate[i] <- last(cum_rate)
}
payments$float.rate <- NA
for (i in 2:nrow(payments)){
t0 = payments$paydate[i-1]
t1 = payments$paydate[i]
rate = float[date >= t0 & date <= t1]
cum_rate = cumprod(rate$gross_daily_rate)
payments$float.rate[i] <- last(cum_rate)
}
payments
payments <- data.table(year = seq(0,4),
paydate = seq(start.date, end.date, by = "year"))
payments$D <- NA
for (i in 2:nrow(payments)){
payments$D[i] <- as.numeric(payments$paydate[i] - payments$paydate[i-1])
}
payments[,fixed.cf := fixed.rate * D/360 * notional]
payments$float.rate <- NA
float <- sofr.frbny[date >= start.date & date <= end.date]
float[, di := c(as.numeric(diff(date)),0)]
float[, gross_daily_rate := 1 + SOFR/100*di/360 ]
float
payments
float
payments
float$di[.N]
float[.N]$di
float[.N]$date
float[.N]$di <- as.numeric(end.date - float[.N]$date)
end.date - float[.N]$date
as.numeric(end.date - float[.N]$date)
float$di[.N]
float[.N]$di
float[.N]$di <- as.numeric(end.date - float[.N]$date)
float[.N]$di[1] <- as.numeric(end.date - float[.N]$date)
float[1,.N]$di <- as.numeric(end.date - float[.N]$date)
float[.N]$di <- as.numeric(end.date - float[.N]$date)
float
float$di[nrow(float)]
as.numeric(end.date - float[.N]$date)
float[.N]$di
float[.N]$di <- as.numeric(end.date - float[.N]$date)
float$di[.N] <- as.numeric(end.date - float[.N]$date)
float
float[.N, di:= as.numeric(end.date - float[.N]$date)]
float[, gross_daily_rate := 1 + SOFR/100*di/360 ]
float
float[.N]
float[, cum_rate := cumprod(gross_daily_rate)]
float
float[.N]
float[.N]$cum_rate
payments
payments[2]
float.cf <- (float[.N]$cum_rate - 1) * payments[2]$D/360 * notional
float.cf
answer12 = float.cf              ### replace NA with R code generating the answer
cat("Answer Q12:", answer12,'\n')
answer12 = round(float.cf)              ### replace NA with R code generating the answer
cat("Answer Q12:", answer12,'\n')
# start question 15
load("merton_70.RData")
View(merton_data)
merton_data
set.seed(437123)
?random
?Random
?randint()
?set.seed()
?random()
?random
??random
View(sr3.fut)
sr3.fut[, forw := (100 - SettlePrice)/100 ]
payment
payments
fixed.rate <- 0.045
notional <- 100000000
start.date <- DATE(2023,12,20)
end.date <- DATE(2027,12,20)
payments <- data.table(year = seq(0,4),
paydate = seq(start.date, end.date, by = "year"))
payments$D <- NA
for (i in 2:nrow(payments)){
payments$D[i] <- as.numeric(payments$paydate[i] - payments$paydate[i-1])
}
payments[,fixed.cf := fixed.rate * D/360 * notional]
float <- sofr.frbny[date >= start.date & date <= end.date]
float[, di := c(as.numeric(diff(date)),0)]
float[.N, di:= as.numeric(end.date - float[.N]$date)]
float[, gross_daily_rate := 1 + SOFR/100*di/360 ]
float[, cum_rate := cumprod(gross_daily_rate)]
float.cf <- (float[.N]$cum_rate - 1) * payments[2]$D/360 * notional
answer12 = round(float.cf)              ### replace NA with R code generating the answer
cat("Answer Q12:", answer12,'\n')
payments
Dfac = data.table(date=c(sr3.fut$StartDt[1],sr3.fut$MatDt))
Dfac
Dfac[, di := c(0,as.numeric(diff(date)))]
Dfac[, forw:= c(0,sr3.fut$forw)]
Dfac
Dfac[, disfac := 1]
Dfac
for (i in 2:nrow(Dfac)) {
Dfac$disfac[i] = Dfac$disfac[i-1]/(1+Dfac$forw[i]*Dfac$di[i]/360)
}
Dfac
payments
payments[, disfac := spline(Dfac$date, Dfac$disfac, xout = paydate, method="natural")]
spline(Dfac$date, Dfac$disfac, xout = payments$paydate, method="natural")
payments[, disfac := spline(Dfac$date, Dfac$disfac, xout = paydate, method="natural")$y]
payments
payments[, pv := fixed.cf*disfac]
payments
market.value <- sum(payments)
market.value <- sum(payments$pv)
market.value
market.value <- sum(payments[-1]$pv)
market.value
na.omit(payments$pv)
na.omit(payments)
market.value <- sum(na.omit(payments)$pv)
market.value
answer13 = round(market.value)                   ### replace NA with R code generating the answer
cat("Answer Q13:", answer13,'\n')
View(qtree)
View(ztree)
answer16 = NA                   ### replace NA with R code generating the answer
# start question 16
prt.tree(ztree)
library
library(quantmod)
library(quantmod)
# start question 16
prt.tree(ztree)
?prt.tree()
?prt.tree
# start question 16
prt.tree <- function(tree,digit=2) {
nt <- nrow(tree)
# transpose tree
trantree <- t(tree)
nt1 <- 2*nt-1
bintree  <- matrix(rep("",nt1*nt),nrow=nt1,ncol=nt)
# convert to bin tree
i1 <- nt
for (j in 1:nt) {
i1 <- nt-j+1
for (i in 1:j) {
bintree[i1,j] <- as.character(round(trantree[i,j],digit))
i1 <- i1 + 2
}
}
rownames(bintree) <- rep("",nt1)
colnames(bintree) <- rep("",nt)
return(noquote(bintree))
}
prt.tree(qtree)
prt.tree(qtree)
prt.tree(ztree)
prt.tree(ztree)
ztree[0,0]
ptree = matrix(0,nrow=N+1, ncol=N+1)
N <- 3
ptree = matrix(0,nrow=N+1, ncol=N+1)
ptree[N+1,c(1:(N+1))] = rep(100,(N+1))
prt.tree(ptree)
for (i in N:1) {
i1 = i+1
ptree[i,1:i] = (qtree[i,1:i]*(ptree[i+1,1:i])+
(1-qtree[i,1:i])*(ptree[i+1,2:i1]))/(1+ztree[i,1:i]/m)^deltm
}
N <- 3
m      <- 2
delt   <- 0.5
ptree = matrix(0,nrow=N+1, ncol=N+1)
ptree[N+1,c(1:(N+1))] = rep(100,(N+1))
prt.tree(ptree)
for (i in N:1) {
i1 = i+1
ptree[i,1:i] = (qtree[i,1:i]*(ptree[i+1,1:i])+
(1-qtree[i,1:i])*(ptree[i+1,2:i1]))/(1+ztree[i,1:i]/m)^deltm
}
deltm <- delt*m
for (i in N:1) {
i1 = i+1
ptree[i,1:i] = (qtree[i,1:i]*(ptree[i+1,1:i])+
(1-qtree[i,1:i])*(ptree[i+1,2:i1]))/(1+ztree[i,1:i]/m)^deltm
}
prt.tree(ptree)
ptree
ztree
prt.tree(ztree)
ztree
ztree[3,2]
answer19 = ztree[3,2]                 ### replace NA with R code generating the answer
cat("Answer Q19:", answer19,'\n')
N <- 8
m      <- 2
delt   <- 0.5
deltm <- delt*m
ptree = matrix(0,nrow=N+1, ncol=N+1)
ptree[N+1,c(1:(N+1))] = rep(100,(N+1))
for (i in N:1) {
i1 = i+1
ptree[i,1:i] = (qtree[i,1:i]*(ptree[i+1,1:i])+
(1-qtree[i,1:i])*(ptree[i+1,2:i1]))/(1+ztree[i,1:i]/m)^deltm
}
prt.tree(ptree)
prt.tree(ptree)
ptree[0.0]
ptree[0,0]
ptree[1,1]
answer20 =  round(ptree[1,1],3)         ### replace NA with R code generating the answer
cat("Answer Q20:", answer20,'\n')
# start question 21
N <- 6
m <- 2
delt  <- 0.5
deltm <- delt*m
ptree <- matrix(0,nrow=N+1, ncol=N+1)
ptree[N+1,c(1:(N+1))] = rep(100,(N+1))
for (i in N:1) {
i1 = i+1
ptree[i,1:i] = (qtree[i,1:i]*(ptree[i+1,1:i])+
(1-qtree[i,1:i])*(ptree[i+1,2:i1]))/(1+ztree[i,1:i]/m)^deltm
}
prt.tree(ptree)
ptree[1,1]
round(ptree[1,1],3)
answer21 = round(ptree[1,1],3)     ### replace NA with R code generating the answer
cat("Answer Q21:", answer21,'\n')
# end   question 21
#----------------------------------------------------
# start question 22
N <- 8
m <- 2
delt  <- 0.5
deltm <- delt*m
ptree <- matrix(0,nrow=N+1, ncol=N+1)
ptree[N+1,c(1:(N+1))] = rep(100,(N+1))
for (i in N:1) {
i1 = i+1
ptree[i,1:i] = (qtree[i,1:i]*(ptree[i+1,1:i])+
(1-qtree[i,1:i])*(ptree[i+1,2:i1]))/(1+ztree[i,1:i]/m)^deltm
}
prt.tree(ptree)
ptree
nodes <- 1+2+3+4+5+6+7+8+9
answer22 = nodes              ### replace NA with R code generating the answer
cat("Answer Q22:", answer22,'\n')
